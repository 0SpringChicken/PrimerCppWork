// Test_Chapter_13.cpp : This file contains the 'main' function. Program execution begins and ends there.
//
// 第13章  拷贝控制 20230810 Thursday

#include "stdafx.h"

//13.4 验证
class Point
{
public:
    Point() { std::cout << "默认构造函数" << std::endl; }
    Point(const Point& pi){ std::cout << "默认拷贝函数" << std::endl; }
};
Point global;
Point foo_bar(Point arg) // 第一次
{
    Point local = arg, * heap = new Point(global); // 第二次  第三次
    *heap = local;
    Point pa[4] = { local,*heap }; // 第四次 第五次
    return *heap;// 第六次
}

int main()
{
    // 知识点：拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数
    // 构造函数定义了用相同类型的另一个对象初始化本对象做什么
    // 运算符定义了讲一个对象赋予同类型的另一个对象时做什么
    // 析构函数定义销毁时做什么  都是拷贝控制操作

    // 如果一个构造函数的第一个参数是自身的引用，而其他的参数都有默认值，则此构造函数是拷贝构造函数
    // 即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数
    // 对某些类来说，合成拷贝构造函数用来阻止我们拷贝该类类型的对象
    
    // 拷贝初始化会发生的情况：
    // 将一个对象作为实参传递给一个非引用类型的形参
    // 从一个返回类型为非引用类型的函数返回一个对象
    // 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

    Point fu;  
    Point fu1 = foo_bar(fu); 

    // 拷贝赋值运算符
    // 析构函数
    // 三/五法则
    // 当我们决定一个类是否要定义它自己版本的拷贝控制成员时
    // 一个基本原则是首先确定这个类是否需要一个析构函数
    // 需要拷贝操作的类也需要赋值操作，反之亦然
    // =default 显式地要求编译器生成合成的版本只能对具有合成版本的函数使用

    // 阻止拷贝  就要定义删除的函数=delete必须出现在函数第一次声明的时候 可以对任意的函数指定
    // 特殊的 析构函数不能是删除的成员

    // 行为像值的类 对于类管理的资源，每个对象都应该拥有一份自己的拷贝
    // 行为像指针的类 需要为其定义拷贝构造函数和拷贝赋值运算符 拷贝指针成员本身而不是它指向的string
    // 要定义自己的引用计数

    // 交换操作
}

